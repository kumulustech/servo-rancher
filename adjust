#!/usr/bin/env python3
import sys
import os
import errno
import subprocess
import time
import json
import argparse

from client import Client
from client import Config

json_enc = json.JSONEncoder(separators=(",",":")).encode

# === constants
Gi=1024*1024*1024
MEM_STEP=64*1024*1024 # minimal useful increment in mem limit/reserve, bytes
CPU_STEP=0.01 # 1% of a core (even though 1 millicore is the highest resolution supported by k8s)
MAX_MEM=1*Gi # bytes, may be overridden to higher limit
MAX_CPU=3.5  # cores
#MAX_REPLICAS=1000 # arbitrary, TBD

def numval(v,min,max,step=1):
    """shortcut for creating linear setting descriptions"""
    return {"value":v,"min":min,"max":max, "step":step, "type": "range"}

def cpuunits(s):
    '''convert a string for CPU resource (with optional unit suffix) into a number'''
    if s[-1] == "m": # there are no units other than 'm' (millicpu)
        return ( float(s[:-1])/1000.0 )
    else:
        return (float(s))

# valid mem units: E, P, T, G, M, K, Ei, Pi, Ti, Gi, Mi, Ki
# nb: 'm' suffix found after setting 0.7Gi
mumap = {"E":1000**6,  "P":1000**5,  "T":1000**4,  "G":1000**3,  "M":1000**2,  "K":1000, "m":1000**-1,
         "Ei":1024**6, "Pi":1024**5, "Ti":1024**4, "Gi":1024**3, "Mi":1024**2, "Ki":1024}
def memunits(s):
    '''convert a string for memory resource (with optional unit suffix) into a number'''
    for u,m in mumap.items():
        if s.endswith(u):
            return ( float(s[:-len(u)]) * m )
    return (float(s))

version="0.1"

if __name__ == "__main__":
    config = Config()
    client = Client(config)

    parser = argparse.ArgumentParser(description='Adjust Rancher Stack Settings')
    parser.add_argument('stackname', nargs='?', help='Name of the stack to update. Pass a capability.json file to update that stack.', default=None)
    parser.add_argument('--version', help='Print the current version', action='store_true')
    parser.add_argument('--info', help='Print version and capabilities in JSON.', action='store_true')
    parser.add_argument('--describe', nargs='?', help='Describe actions which can be performed on a stack.', action='append')
    parser.add_argument('--action', nargs=2, help='Perform a service action')
    parser.add_argument('--capabilities', nargs='?', help='List the possible capabilites of a given service.', action='append')

    args = parser.parse_args()
    if args.version:
        print(version)
    elif args.info:
        print(json.dumps({"version":version, "has_cancel":True}))
    elif args.capabilities:
        client.print(client.capabilities(args.capabilities[0]))
    elif args.describe:
        stack_id = args.describe[0]
        try:
            r = client.describe(stack_id)
        except (Exception) as e:
            print(e, file=sys.stderr)
            print(json.dumps({"error":e.__class__.__name__, "class":"failure", "message":str(e)}))
            sys.exit(3)

        client.print(r)
    elif args.action:
        stack_id = args.action[0]
        # * cancelrollback
        # * cancelupgrade
        # * finishupgrade
        # * rollback
        action = args.action[1]
        try:
            r = client.services(name=stack_id, action=action)
        except (Exception) as e:
            print(e, file=sys.stderr)
            print(json.dumps({"error":e.__class__.__name__, "class":"failure", "message":str(e)}))
            sys.exit(3)

        client.print(r)
    elif args.stackname:
        stackname = args.stackname

        data = json.load(sys.stdin)
        try:
            client.services(name=stackname, body=data[stackname])
        except Exception as e:
            print(e, file=sys.stderr)
            print(json.dumps({"error":e.__class__.__name__, "class":"failure", "message":str(e)}))
            sys.exit(3)
    else:
        parser.print_help()
